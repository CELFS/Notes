### 01-2 虚拟化（内存虚拟化）

Date：2023/04/12

------





[TOC]



------



### 第12章 关于内存虚拟化的对话

* 摘录
  * 学生就应该问问题，对吧？实际上教授们的意思：提出问题，仅当它们是**好问题**，而且你实际上已经对这些问题**进行了一些思考**。
  * 虚拟内存很复杂，需要我们理解关于硬件和操作系统**交互方式**的更多复杂细节。
  * 有很多细节，你必须牢记它们，才能真正对发生的事情建立一个思维模型。将从简单的开始，如基址/界限，慢慢增加复杂性以应对新的挑战，如TLB和多级页表。最终，我们将能够描述一个全功能的现代虚拟内存管理程序的工作原理。（学习策略 + 最终目的）
  * 虚拟地址（every address generated by a user program is a virtual address）（对于用户程序）、易于使用（ease of use）、地址空间（address space）、隔离（isolation）、保护（protection）



* 2023/04/12 18:57:45

------



### 第13章 抽象：地址空间

* 早期系统（几乎没有抽象）
* 多道程序和时分共享
  * 多道程序（multiprogramming）、有效利用率（utilization）、效率（efficiency）、分时系统的时代、交互性（interactivity）
* 地址空间
  * **关键问题：如何虚拟化内存**
    * 虚拟化内存：OS 在单一的物理内存上为多个运行的进程（所有进程共享内存）构建一个私有的、可能很大的地址空间的抽象？
    * 内存虚拟化的关键：出于某种原因，**必须确保不是加载到物理地址** 0，而是物理地址320KB（这是 A 载入内存的地址）
    * 提示：隔离原则
  * 地址空间是运行的程序看到的系统中的内存（易用的**物理内存抽象**，也是了解虚拟化内存的关键）
  * 一个进程的地址空间包含运行的程序的**所有内存状态**
    * 代码
    * 栈：保存当前的函数调用信息，分配空间给局部变量，传递参数和函数返回值
    * 堆：管理动态分配的、用户管理的内存
    * 其他东西（如，静态初始化的变量）
  * 抽象（abstract）、多个线程（threads）、虚拟化内存（virtualizing memory）、虚拟地址（virtual address）、微内核（microkernel）、内存隔离
  * **分析方法：**
    * 先把静态内容固定（静态代码），再考虑可能变化的区域（栈堆）
    * 它们只需要在相反的方向增长（因此未分配区域在栈堆之间，**多线程无效**）

![Snipaste_2023-04-12_19-53-50](images/01-2_虚拟化_内存/Snipaste_2023-04-12_19-53-50.png)

* 目标（为了实现操作系统的工作，需要目标的指导）
  * 透明（transparency）、效率（efficiency）、保护（protection）
  * **程序不应该感知到内存被虚拟化的事实**，时空效率，隔离保护
  * 补充：你看到的所有地址都不是真的（**打印均为虚拟地址，**只有 OS 和硬件知道物理地址）
  * 重要**子系统**：虚拟内存。
    * 虚拟内存系统负责为程序提供一个巨大的、稀疏的、私有的地址空间的假象，其中保存了程序的所有指令和数据。
    * OS 在专门硬件的帮助下，通过每一个虚拟内存的索引，将其转换为物理地址，物理内存根据获得的物理地址去获取所需的信息。



* 2023/04/12 20:44:49

------



### 第14章 插叙：内存操作API

* 关键问题：如何分配和管理内存

* 内存类型
  * **栈（stack）**内存（自动（automatic）内存，**隐式**）
    * 若希望某些信息存在于函数调用之外，建议不要将它们放在栈上
  * **堆（heap）**内存（于是有了 heap，满足对长期内存的需求，**显式**）
    * 显式+变化用法，堆内存对用户和系统提出了更大的挑战
  
* `malloc()` 调用（库调用）
  
  * 不直接传入 `size_t` 类型参数（数值），而是使用各种函数和宏（如 int 乘法）
  * `double *d = (double *) malloc(10 * sizeof(double));` 
  * `sizeof()` 返回的注意事项（默认返回类型指针大小，除非使用初始化数组）
  * 字符串声明 `malloc(strlen(s) + 1)` （+1 为字符串结束符预留）
  * 强制类型转换（cast）（实际没有做什么）
  
* `free()` 调用（库调用）
  
  * 分配内存是等式的简单部分，知道**何时、如何**以及**是否释放内存**是困难的部分
  * 介绍一个由 `malloc()` 返回的指针（参数）
  
* **常见错误**
  
  * 概念
    
    * 自动内存管理（automatic memory management）、垃圾收集器（garbage collector）、滥用内存
    
  * 忘记分配内存
  
    * 段错误（segmentation fault）
  
    * 提示：它编译过了或它运行了!=它对了（或 `strdup()` ）
  
      ```C
      char *src = "hello";
      char *dst = (char *) malloc(strlen(src) + 1);
      strcpy(dst, src); // work properly
      ```
  
  * 没有分配足够的内存（“几乎” 足够是不够的，许多系统漏洞的来源）
  
    * 缓冲区溢出（buffer overflow）
    * 经验：即使它正确运行过一次，也不意味着它是正确的。
  
  * 忘记初始化分配的内存
  
    * 未初始化的读取（uninitialized read）：可能会在堆中读到乱七八糟的数据，不排除读到随机和有害的东西。
  
  * 忘记释放内存
  
    * 内存泄露（memory leak）：尤其注意在**长时间**运行的应用程序或系统中
    * 习惯：释放显式分配的每个字节
  
  * 在用完之前释放内存
  
    * 悬挂指针（dangling pointer）：提前，导致重新利用了错误释放的内存。
  
  * 重复释放内存
  
    * 重复释放（double free）：未定义。
  
  * 错误地调用 `free()` 
  
    * 无效的释放（invalid free）：传入了非 `malloc()` 申请的指针/值
    * 补充：为什么在你的进程退出时没有内存泄露（**短时间**运行的程序）
      * 没有任何内存会丢失，原因：系统中实际存在两级内存管理
        * 第一级是由操作系统执行的内存管理
        * 第二级管理在每个进程中
      * purify、valgrind 内存定位工具
  
* 底层操作系统支持

  *  `brk` 、分断（break）位置（即堆结束的位置）、`sbrk` 、`mmap()` 、匿名（anonymous）内存区域、交换空间（swap space）
  * 不应该直接调用 `brk` 或 `sbrk`，它们被内存分配库使用。建议坚持使用 `malloc()` 和 `free()` 。

* 其他调用

  * `calloc()` （置零）、`realloc()` （更大，赋值）

* 疑问

  * 内存泄漏与 temp 重启系统未清理是否有关？
  * “Advanced Programming in the UNIX Environment”W. Richard Stevens and Stephen A. Rago Addison-Wesley, 2005 这本书建议读很多遍





* 2023/04/12 23:11:53
* 2023/04/14 17:29:31

------



### 第15章 机制：地址转换

* 关键问题：如何高效、灵活地虚拟化内存
* 假设
* 一个例子
* 动态（基于硬件）重定位
  * 转换示例
* 硬件支持：总结
* 操作系统的问题









------



### 第16章 分段

### 第17章 空闲空间管理

### 第18章 分页：介绍

### 第19章 分页：快速地址转换（TLB）

### 第20章 分页：较小的表

### 第21章 超越物理内存：机制

### 第22章 超越物理内存：策略

### 第23章 VAX/VMS虚拟内存系统

### 第24章 内存虚拟化总结对话



------

