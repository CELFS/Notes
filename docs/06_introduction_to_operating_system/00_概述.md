---
sidebar_label: "00 第2章 操作系统介绍"
---

### 00 第2章 操作系统介绍

Date：2023/04/06

------



* **虚拟化（virtualization）**
  * **关键问题：如何将资源虚拟化**
  * 定义：
    * 虚拟化 CPU，营造在单个 CPU 有多个 CPU 的假象
    * 虚拟化内存，营造每个进程拥有自己的私有虚拟地址空间的假象
  * 摘录：同时运行的程序（或一个程序的不同实例），看似都在访问自己的的私有虚拟地址空间，一个正在运行程序中的内存引用不会影响其他进程（或操作系统本身）的地址空间。但实际情况是，物理内存是由操作系统管理的共享资源。

* **并发（concurrency）**
  * **关键问题：如何构建正确的并发程序**
  * 定义：同时地（并发地）处理很多事情时出现且必须解决的一系列问题。
  * 摘录：奇怪的、不寻常的结果与指令如何执行有关，指令每次执行一条。举例的程序需要 3 条指令：一条将计数器的值从内存加载到寄存器，一条将其递增，另一条将其保存回内存。因为这 3 条指令并不是以原子方式（atomically）执行（所有的指令一次性执行）的，所以奇怪的事情可能会发生。
* **持久性（persistence）**
  * **关键问题：如何持久地存储数据**
  * 定义：系统内存设备以易失方式存储数值，鉴于数据对用户很重要，而管理持久的数据，需要有专门的软件负责，因此有了文件系统。
  * 摘录：文件系统必须做很多工作：首先确定新数据将驻留在磁盘上的哪个位置，然后在文件系统所维护的各种结构中对其进行记录。大多数文件系统首先会延迟这些写操作一段时间，希望将其批量分组为较大的组。为了处理写入期间系统崩溃的问题，大多数文件系统都包含某种复杂的写入协议，如日志（journaling）或写时复制（copy-on-write），仔细排序写入磁盘的操作，以确保如果在写入序列期间发生故障，系统可以在之后恢复到合理的状态。
* **操作系统**
  * **工作：**
    * 取得物理资源
    * 对物理资源进行虚拟化
    * 处理与并发有关的棘手问题
    * 持久化地存储文件
  * 目标：
    * 建立一些抽象（abstraction），让系统方便和易于使用
    * 提供高性能（performance），即最小化操作系统的开销（minimize the overhead），时间、空间
    * 在应用程序之间以及在 OS 和应用程序之间提供保护（protection），隔离（isolation）
    * 提供高度的可靠性（reliability）
    * 其他
      * 能源效率（energy-efficiency）
      * 安全性（security）
      * 移动性（mobility）
  * 摘录：用 C 这样的高级语言编写这样的程序不用考虑汇编，用汇编写代码不用考虑逻辑门，用逻辑门来构建处理器不用太多考虑晶体管。
* **OS 简史**
  * 早期操作系统：只是一些库
    * 概要：没有做太多事情，只是一组常用函数库，让 “OS” 提供这样的 API。
    * 批处理、操作员，无交互、过程调用（procedure call）
  * 超越库：保护
    * 概要：意识到代表操作系统运行的代码是特殊的，应用程序通过系统调用提权。
    * 系统调用、陷阱（trap）、陷阱处理程序（trap handler）、用户模式（user mode）、内核模式（kernel mode）、陷阱返回（return-from-trap）
  * 多道程序时代
    * 概要：操作系统不是一次只运行一项作业，而是将大量作业加载到内存中并在它们之间快速切换，从而提高CPU利用率。在中断存在的情况下，确保操作系统正常运行是一个很大的挑战。
    * 小型机（minicomputer）时代、多道程序（multiprogramming）、内存保护（memory protection）、并发（concurrency）、UNIX
    * 感悟：本地跑深度学习模型，带来的大量资源占用，导致等待期间如同回到那个年代，所以还是云计算更方便，或者搭专用机器跑模型。
  * 摩登时代
    * 概要：个人计算机普及，但 PC 的 OS 舍弃了内存保护，导致 OS 发展倒退，后来随着老功能的引入而逐渐进步。
    * 个人计算机（Personal Computer，PC）、Apple II（第一代 macOS）、IBM PC（DOS，倒退）、macOS X（进步）、Windows NT（进步）
* UNIX
  * 统一原则：构建小而强大的程序
  * 管道（pipe）、元（meta-level）编程、C 编译器、开放源码软件（open-source software）、发行版（Berkeley Systems Distribution，BSD）
  * 变体：Sun Microsystems 的 SunOS、IBM 的 AIX、HP 的 HPUX（又名H-Pucks）以及 SGI 的 IRIX
* Linux
  * 互联网时代、智能手机、NeXTStep
  * 摘要：该版本严重依赖最初系统背后的原则和思想，但没有借用原来的代码集，从而避免了合法性问题。
* **本书不讲**
  * 网络代码、图形设备、更深的安全问题
* **疑问**
  * 为什么说一个操作系统与具有不同硬件的电脑适配程度不同？
    * 因为 OS 的工作首先需要取得物理资源，取得资源的多少、取得资源的方式，又决定了后面的一系列处理工作
  * 如何衡量 OS 与硬件的适配程度？
  * 通常预装的系统是最适配的吗？那么升级之后呢？向下兼容？
* 提示/摘录
  * 文献引用的简要说明方式，指路讲得很好
  * 健全与完善自己知识的一个好方法，就是**尽可能多地听取其他观点**，然后在此问题上**扩展自己的观点和想法**
  * **“第二系统效应” 的误区**（过度设计、过度谨慎、过度自信，看到改进机会而不自觉地把项目复杂化，特别容易出现进度延误）
  * 阅读这些旧的系统文件，能看到在20世纪60年代后期技术发展的进程，这很有意思
  * 写自己的课程注解的好处是：你可以为自己的研究做广告
  * 我们**只关心**大多数程序所假设的简单模型：指令似乎按照有序和顺序的方式逐条执行。
  * 请注意我们如何利用& 符号同时运行 4 个进程
  * 事实证明，**随机化**可以很好地抵御某些安全漏洞。特别是如果你想学习如何通过堆栈粉碎黑客对计算机系统的攻击入侵。
  * Emacs，如果你用的不是真正的代码编辑器，那更糟糕。
  * 让你注意到不太适合文本主线的各种内容。我们甚至会用它们来开玩笑，为什么在这个过程中没有一点乐趣？
* 补充
  * 参考文献、书目延伸学习（大量）



2023/04/06 23:39:03

------


