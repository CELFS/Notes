---
sidebar_label: "02 并发"
---

### 02 并发

Date：2023/05/28 13:01:27

------



[TOC]



------



### 第25章 关于并发的对话

* 摘录
  * 例子：桃子，每个食客首先在视觉上识别桃子，然后试图抓住并吃掉桃子。这种方法有什么问题？
  * 让很多人同时抓起桃子，速度更快。但以我的方式，我们只是一次一个，这是正确的，但速度较慢。最好的方法是既快速又正确。
  * 永远不要忘记具体概念。
  * 多线程应用程序中，每个线程都像在这个程序中运行的独立代理程序，代表程序做事。但是这些线程访问内存，对于它们来说，每个内存节点就像一个桃子。如果我们不协调线程之间的内存访问，程序将无法按预期工作。懂了吗？
  * 操作系统本身是第一个并发程序——它必须非常小心地访问自己的内存，否则会发生许多奇怪而可怕的事情。
* 多线程（multi-threaded）应用程序、线程（thread）、锁（lock）、条件变量（condition variable）



------



### 第26章 并发：介绍

* 线程（thread）：

  * 定位：为单个运行进程提供的新抽象。
  * 复用、执行点、多线程（multi-threaded）、程序计数器；每个线程类似于**独立的**进程，**但它们共享地址空间**，从而能够访问相同的数据。
  * 结构对比：程序计数器（PC）、一组计算寄存器、线程（T1）、线程（T2）、上下文切换（context switch）、进程控制块（Process Control Block，PCB）、线程控制块（Thread Control Block，TCB）、线程本地（thread-local）存储
  * 主要区别：
    * 地址空间保持不变（即不需要切换当前使用的页表）。
    * 单线程（single-threaded）进程（一个栈），多线程（每个线程一个栈）

  ![img](images/02-1_并发/epub_30179184_118.jfif)

* 实例：线程创建

  * 类似函数调用，为被调用例程创建一个新的执行线程，可独立于调用者运行，返回顺序不定。

* 为什么更糟糕：共享数据

  * 确定的（deterministic）、反汇编程序（disassembler）
  * `prompt> objdump -d main` （产生程序中所有指令的长列表）

* 核心问题：不可控的调度

  * 时钟中断发生、寄存器虚拟化、例子（51 覆盖，少了一次递增）、可变长度指令、**竞态条件（race condition）**、不确定的（indeterminate）、临界区（critical section）、互斥（mutual exclusion）
  * 由于运气不好（即在执行过程中发生的上下文切换），我们得到了错误的结果。
  * 临界区是访问共享变量（或更一般地说，共享资源）的代码片段，**一定不能**由多个线程同时执行。

  ![img](images/02-1_并发/epub_30179184_122.jfif)

* 原子性愿望

  * 原子方式（atomically）执行（无中间态）、同步原语（synchronization primitive，有用指令+通用集合）、多线程代码、同步受控访问、互斥原语、条件变量（condition variable）
  * **临界区**：指访问共享资源的一段代码，资源通常是一个变量或数据结构。
  * **竞态条件**：出现在多个执行线程大致同时进入临界区时，它们都试图更新共享的数据结构，导致了令人惊讶的（也许是不希望的）结果。
  * **不确定性**：程序由一个或多个竞态条件组成，程序的输出因运行而异，具体取决于哪些线程在何时运行，从而导致结果是不确定的。
  * **不确定性**：
  * **互斥执行**：可以保证只有一个线程进入临界区，从而避免出现竞态，并产生确定的程序输出。
  * 关键问题：如何实现同步

* 还有一个问题：等待另一个线程

  * 线程的**交互**
    * 访问共享变量
    * 线程等待

* 小结：为什么操作系统课要研究并发

  * 操作系统是第一个并发程序、inode、不合时宜的中断、**原子操作**、事务（transaction）
  * 原子化（atomic）：“全部或没有”

* 疑问 / 感悟

  * “封装” 是否属于利用原子性特征？合适的抽象，隐蔽某些细节，看作一个整体。
  * 线程的交互，更像是线程之间存在的各种相互作用情况。



2023/05/28 20:31:17

------



### 第27章 插叙：线程API

* 关键问题：如何创建和控制线程？
  * 创建、控制、接口、易用、实用
* 线程创建
  * 创建新线程、POSIX、函数指针（function pointer）、void指针、参数打包、返回值打包
  * 另一个活着的执行实体，它有自己的调用栈，与程序中所有当前存在的线程在相同的地址空间内运行。
* 线程完成
  * 必须调用函数 `pthread_join()` ，但并非所有多线程代码都使用 join 函数（多线程Web服务器，长期程序，但 join 可确保所需工作完成）
  * 过程调用（procedure call）
* 锁（lock）
  * 临界区 => 锁保护
  * 缺乏正确的初始化（lack of proper initialization）、在调用获取锁和释放锁时没有检查错误代码
* 条件变量（condition variable）
  * 线程库、主要组件、标记变量（易错、自旋）、标志同步、编译并发程序
  * `int pthread_cond_wait(); ` 
  * `int pthread_cond_signal();` 
* 编译和运行
  * `pthread.h` 
  * `prompt> gcc -o main main.c -Wall -pthread` 
* 线程 API 指导
  * 保持简洁。
  * 让线程交互减到最少。
  * 初始化锁和条件变量。
  * 检查返回值。
  * 注意传给线程的参数和返回值。
  * 每个线程都有自己的栈。
  * 线程之间总是通过条件变量发送信号。（线程局部变量、线程之间共享数据，值要在堆或者其他全局可访问的位置）
  * 多查手册。

* 疑问
  * 如何理解 “因此，将唤醒视为某种事物可能已经发生变化的暗示，而不是绝对的事实，这样更安全。” ？
* 摘录
  * 线程创建、通过锁创建互斥执行、通过条件变量的信号和等待。
  * `man -k pthread` 
  * 复杂的、正确的、高性能的
  * 线程难的部分不是API，而是如何构建并发程序的棘手逻辑



2023/05/31 22:34:29

------



### 第28章 锁

* 锁的基本思想
  * 锁变量（lock variable）、可用的（available / unlocked / free）、被占用的（acquired / locked / held）、（锁的）持有者（owner）
  * 锁为程序员提供了最小程度的调度控制。
  * 线程（视为程序员创建的实体）、控制权（获得）
  * 目的：给临时区加锁，可保证临时区只有一个线程活跃（混乱 => 可控）。
* Pthread 锁
  * POSIX 库、互斥量（mutex）
  * 预留参数入口，可用不同的锁保护不同的变量：这样可以增加并发，不同于任何临界区都使用同一个大锁（ **粗粒度的锁策略** ），通常大家会用不同的锁保护不同的数据和结构，从而允许更多的线程进入临界区（ **细粒度的方案** ）。
* 实现一个锁
  * 关键问题：怎样实现一个锁
    * 高效（低成本提供互斥）、特性、硬件支持、系统支持（计算机体系结构的指令集：硬件原语）、互斥原语
* 评价锁
  * 互斥（mutual exclusion）、公平性（fairness）、性能（performance）
* 控制中断
  * 在临界区关闭中断（早期，为单处理器系统开发）、缺点很多（依赖特权操作，不通用）、不支持多处理器、中断丢失可能会导致严重的系统问题、效率低
  * Dekker 算法（Dekker’s algorithm）、Peterson算法（Peterson’s algorithm，针对两个线程，flag、turn）、松散内存一致性模型
* 测试并设置指令（原子交换）
  * 测试并设置指令（test-and-set instruction）/ 原子交换（atomic exchange）、自旋等待（spin-wait，性能浪费)、并发编程（正确性）
* 实现可用的自旋锁
  * SPARC：ldstub（load/store unsigned byte，加载/保存无符号字节）
  * x86：xchg（atomic exchange，原子交换）
  * 测试并设置指令、原子地（atomically）、自旋锁（spin lock）、抢占式调度器（preemptive scheduler，即不断通过时钟中断一个线程，运行其他线程）
  * 实现：将测试（test旧的锁值）和设置（set新的值）合并为一个原子操作
  * 提示：从恶意调度程序（malicious scheduler）的角度想想并发
* 评价自旋锁
  * 正确性（correctness）：能够互斥
  * 公平性（fairness）：无
  * 性能（performance）：单 CPU 开销很大，多 CPU 性能好（临界区短）
* 比较并交换
  * 比较并交换指令（SPARC：compare-and-swap，x86：compare-and-exchange）、无等待同步（wait-free synchronization）
* 链接的加载和条件式存储指令
  * 链接的加载（load-linked）、条件式存储（store-conditional）、Alpha、PowerPC、ARM、劳尔定律（Lauer’s Law，少即是多）、布尔条件短路、条件式存储失败的发生
  * store-conditional 关键区别：只有上一次加载的地址在期间都没有更新时，才会成功，（同时更新刚才链接的加载的地址的值）。
* 获取并增加（fetch-and-add）
  * 变量 `ticket` 和 `turn` 构建锁
  * 能够保证所有线程都能抢到锁（unlock 是增加 turn，从而下一个等待程序可进入临界区）
* 自旋过多：怎么办
  * 基于硬件：简单、有效
  * 缺点：某些场景效率低下（不必要地自旋，带来时间片浪费，N-1）
  * 关键问题：怎样避免自旋
* 简单方法：让出来吧，宝贝
  * 思想：在要自旋的时候，放弃 CPU。
  * 利用原语 `yield()` ，使得运行态变为就绪态，从而允许其他线程运行。
  * 本质：取消调度（deschedules）
  * 轮转调度程序
* 使用队列：休眠替代自旋
  * 目标：必须显式地施加某种控制，决定锁释放时，谁能抢到锁。
  * `park()` 、`unpark(threadID)` 、`guard` 、`separk()` 、唤醒/等待竞争（wakeup/waiting race）
  * 线程被唤醒时，就像是从park()调用返回。但是，此时它没有持有guard，所以也不能将flag设置为1。
* 不同操作系统，不同实现
  * `futex`：每个 futex 都关联一个特定的物理内存位置，也有一个事先建好的内核队列。
  * ``futex_wait(address, expected)` 、`futex_wake(address)` 
  * `nptl` 库的 `lowlevellock.h`（源于 `gnu libc` 库）：类似一个整数掰开使用，分别标记锁是否被持有、等待者个数、负数则被持有
* 两阶段锁（two-phase lock，Dahm 锁）
  * 杂合（hybrid）方案
  * 步骤
    * 两阶段锁的第一阶段会先自旋一段时间，希望它可以获取锁。
    * 若第一个自旋阶段未获得锁，第二阶段调用者会睡眠，直到锁可用。
* 疑问 / 感悟
  * 目前为止，这里前后提到的工具，都是为了解决 51 例子的问题，即临界区带来的计数冲突问题，而解决这个问题的核心，始终围绕着 “原子性”。
  * 了解到 Peterson 算法，想起 Linux 的 `fg` 指令，难道是 flag 的意思吗？
  * 如何理解 “其他线程都在竞争锁，都会在放弃CPU之前，自旋一个时间片，浪费CPU周期。” 以及 “然而，临界区一般都很短，因此很快锁就可用，然后线程B获得锁。” ？
  * 如何理解 “返回该内存地址的实际值，让调用者能够知道执行是否成功。” ？为什么返回的是原来的值？这个信息够用吗？对比前面返回 old，似乎一样的思想。
  * 如何理解 “线程被唤醒时，就像是从park()调用返回。但是，此时它没有持有guard，所以也不能将flag设置为1” ？
* 摘录
  * Pilot操作系统、RDLK（读锁）、Buzz Locks、高度优化的
  * 针对不同锁算法的优秀而全面的调查。
  * 留给读者一个问题：如果我们在park()之后，才把guard设置为0释放锁，会发生什么呢？提示一下，这是有问题的。



2023/06/03 23:29:16 to 28.12，2023/06/04 18:22:58

------



### 第29章 基于锁的并发数据结构

* 关键问题：如何给数据结构加锁？

  * 线程安全（thread safe）、并发访问（concurrently）

* 并发计数器
  * 简单但无法扩展
    * 只是加了一把锁，在调用函数操作该数据结构时获取锁，从调用返回时释放锁。
    * 请注意，如果数据结构导致的运行速度不是太慢，那就没事！如果简单的方案就能工作，就不需要精巧的设计。
    * 观察者（monitor）、完美扩展（perfect scaling）
  
  ![img](images/02-1_并发/epub_30179184_124.jfif)
  
  * 可扩展的计数
  
    * 懒惰计数器（sloppy counter）、局部锁、全局锁、锁同步、频度、阈值 S（sloppiness，越大扩展性越强）
    * 多个局部计数器、一个全局计数器、每个局部计数器有一个锁、全局计数器有一个锁
    * 懒惰计数器是在准确性、性能之间折中
  
    ![img](images/02-1_并发/epub_30179184_126.jfif)
  
* 并发链表
  
  * 异常控制流容易产生错误。
  * 调整代码，让获取锁和释放锁只环绕插入代码的真正临界区。
  * 减少了代码中需要获取锁、释放锁的地方，降低了代码中不小心引入缺陷（诸如在返回前忘记释放锁）的可能性。
  * 扩展链表
    * 过手锁（hand-over-hand locking / 作锁耦合 lock coupling）
      * 原理：每个节点都有一个锁，替代之前整个链表一个锁。
      * 缺点：开销
    * 更多并发不一定更快，可实现两种方案，测试它们的表现，一目了然，或者杂合方案。
    * 当心锁和控制流
  
* 并发队列

  * 添加一把大锁，两个锁 head、tail，假节点

* 并发散列表

  * 散列桶、避免不成熟的优化（premature optimization，Knuth定律）、BKL（大内核锁，big kernel lock）

* 疑问 / 感悟

  * 如何理解 “注意控制流的变化导致函数返回和退出，或其他错误情况导致函数停止执行” ？（状态恢复，易出错）

* 摘录

  * 计数器、链表队列、散列表、B树、数据库课程、非阻塞数据结构、并发算法和数据结构
  * 控制流变化时注意获取锁和释放锁；增加并发不一定能提高性能；有性能问题的时候再做优化。
  * 我们让整个应用的某一小部分变快，却没有提高整体性能，其实没有价值。
  * 将观察者作为并发原语引入。



2023/06/04 20:50:54 to 29.3，2023/06/04 23:13:25

------



### 第30章 条件变量

* 关键问题：如何等待一个条件？
* 定义和程序
  * 条件变量（condition variable）、显式队列、执行状态（即条件，condition）、等待（waiting）、“私有信号量”
  * `pthread_cond_t c;` 、`wait()` 、`signal()` 
* 生产者/消费者（有界缓冲区）问题
  * 通用的信号量、管道（并发进程）、有界缓冲区（共享资源）、一般化、生产者（producer）线程、消费者（consumer）线程
  * 有问题的方案
    * 信号逻辑、信号释义、Mesa 语义（Mesa semantic）、Hoare 语义（Hoare semantic）
  * 较好但仍有问题的方案：使用 While 语句替代 If
    * 总是使用while循环（always use while loop）
    * 信号显然需要，但必须更有指向性。消费者不应该唤醒消费者，而应该只唤醒生产者，反之亦然。
  * 单值缓冲区的生产者/消费者方案
    * 解决：使用两个条件变量，而不是一个，以便正确地发出信号。
    * `empty` 、`fill` 
  * 最终的生产者/消费者方案
    * 缓冲区结构本身、`put()` 、`get()` 、假唤醒（spurious wakeup）
* 覆盖条件
  * 内存不足 => 等待、歧义 => 异常、覆盖条件（covering condition）、保守策略、广播信号、同步原语
* 疑问 / 感悟
  * 这章有较多描述过程的信息，暂未消化。
  * 如何理解 “这段代码是有问题的。假设子线程立刻运行，并且调用thr_exit()。在这种情况下，子线程发送信号，但此时却没有在条件变量上睡眠等待的线程。” ？
  * 从管道的并发，能够很形象地理解并发概念，本质是在排队，而通常是高速地排队，让用户产生两个进程在同时运行的错觉，其实它们在高速地切换？
  * 尽管前面几章出现了多次，但实际还对原语相关的术语不清晰，原语意思为 “可原子执行的语句（块）” ？而同步原语，意思为 “用于实现同步操作的原语” ？
* 摘录
  * [D01] “My recollections of operating system design” E.W. Dijkstra April, 2001 如果你对这一领域的先驱们如何提出一些非常基本的概念（诸如 “中断” 和 “栈” 等概念）感兴趣，那么它是一本很好的读物！



2023/06/08 17:20:11

------



### 第31章 信号量

* 关键问题：如何使用信号量？
* “最短路径” 算法、结构化编程、信号量
* 信号量的定义
  * 定义：有一个整数值的对象，可用两个函数操作。
  * `sem_wait()` 、`sem_post()` 、恒定关系值
* 二值信号量（锁）
  * 信号量用法：
    * 一：用信号量作为锁
    * 二：线程暂停，等待条件的场景
  * 调度程序状态（scheduler state）、二值信号量（binary semaphore）
  * **初始值为 1 ** 
* 信号量用作条件变量
  * **初始值为 0** 
* 生产者/消费者（有界缓冲区）问题
  * 问题：老数据被覆盖
  * 解决方案：增加互斥，问题：死锁
  * 避免死锁：循环等待（互相等待对方）
  * 最终可行方案：只需减少锁的作用域（现在理解，将来使用）
* 读者—写者锁（reader-writer lock）
  * 锁定原语、写锁、读锁、Hill 定律（Hill’s Law，简单笨方法）、辅助函数
  * 问题：公平性不足，开销大，性能劣势
* 哲学家就餐问题（dining philosopher’s problem）
  * 假定有5位“哲学家”围着一个圆桌。每两位哲学家之间有一把餐叉（一共5把）。哲学家有时要思考一会，不需要餐叉；有时又要就餐。而一位哲学家只有同时拿到了左手边和右手边的两把餐叉，才能吃到东西。
  * 关键挑战：如何实现 getforks() 和 putforks() 函数，保证没有死锁，没有哲学家饿死，并且并发度更高（尽可能让更多哲学家同时吃东西）。
  * 有问题的解决方案
    * 死锁（deadlock）：假设每个哲学家都拿到了左手边的餐叉，他们每个都会阻塞住，并且一直等待另一个餐叉。
  * 一种方案：破除依赖
    * 优化：修改某个或者某些哲学家的取餐叉顺序
    * 吸烟者问题（cigarette smoker’s problem）、理发师问题（sleeping barber problem）
* 如何实现信号量
  * 底层同步原语（锁和条件变量）、小心泛化
  * 结构：一把锁、一个条件变量和一个状态的变量
* 疑问 / 感悟
  * 如何确定信号量初始值？按照原文的例子，是结合进程顺序假设的逻辑链反推的。比较不同的路径顺序，如果没有卡住，则有效。
  * 如何理解并发链表 “插入操作会修改链表的状态（因此传统的临界区有用），而查找操作只是读取该结构，只要没有进行插入操作，我们可以并发的执行多个查找操作” ？
  * 可否把锁理解为：一种为了确保在临界区出现时，不会产生有歧义计数的保护性原语（行为封装）？
  * 如何理解 “在这种情况下，读者也会获取写锁，即在writelock信号量上调用sem_wait()，最后调用sem_post()释放lock。” ？
  * `wait()` 传入参数，等待的是谁？而用 `get` 和 `put` 相当于等到获取了相应的锁位为止？
* 摘录
  * 我们首先关注如何使用这些原语，稍后再讨论如何实现。
  * 如果你想追踪自己的例子，那么请尝试一个场景，多个线程排队等待锁。在这样的追踪中，信号量的值会是什么？
  * 问题来了：信号量的初始值应该是多少？
  * 总是优先尝试简单的笨办法。
  * 内核黑客、分层系统式的模块化、暗示、`P()`（代指荷兰语单词 “to probe”），`V()`（代指荷兰语单词 “to test”）



2023/06/09 17:53:56

------



### 第32章 常见并发问题

* 关键问题：如何处理常见的并发缺陷
* 有哪些类型的缺陷：非死锁相关、死锁缺陷
* 非死锁缺陷（97% 如下两类）
  * 违反原子性缺陷（atomicity violation）：“违反了多次内存访问中预期的可串行性（即代码段本意是原子的，但在执行中并没有强制实现原子性）”。
  * 违反顺序缺陷（order violation）：“两个内存访问的预期顺序被打破了（即 A 应该在 B 之前执行，但是实际运行中却不是这个顺序）”
  * 强制顺序、现代代码集、更自动化的代码检查工具
* 死锁缺陷
  * 关键问题：如何对付死锁
  * 为什么发生死锁
    * 组件之间的复杂依赖；
    * 封装（encapsulation）导致模块化和锁不是很契合。
  * 产生死锁的 4 个条件
    * **互斥：**线程对于需要的资源进行互斥的访问（例如一个线程抢到锁）。
    * **持有并等待：**线程持有了资源（例如已将持有的锁），同时又在等待其他资源（例如，需要获得的锁）。
    * **非抢占：**线程获得的资源（例如锁），不能被抢占。
    * **循环等待：**线程之间存在一个环路，环路上每个线程都额外持有一个资源，而这个资源又是下一个线程要申请的。
  * 预防
    * 循环等待
      * 全序（total ordering）、偏序（partial ordering）
      * 顺序只是一种约定，通过锁的地址来强制锁的顺序。
    * 持有并等待：原子地抢锁，任何线程在任何时候抢占锁时，先抢到全局的 prevention 锁（不适用于封装，且可能降低并发）。
    * 非抢占
      * 活锁（livelock）：两个线程有可能一直重复这一序列，又同时都抢锁失败。
      * 解决：先随机等待一个时间
    * 互斥
      * 无等待（wait-free）数据结构、比较并交换指令、链表插入（例子）、传统的锁、无等待同步
    * 通过调度避免死锁
      * 死锁避免（avoidance）、银行家算法
      * 保守的静态方案会明显增加完成任务的总时间。
    * 检查和恢复
      * 允许死锁偶尔发生，检查到死锁时再采取行动
      * 不要总是完美（TOM WEST 定律）：“不是所有值得做的事情都值得做好”。
      * 死锁检测和恢复技术、死锁检测器、资源图、数据库并发



2023/06/10 4:05:44

------



### 第33章 基于事件的并发（进阶）

* 关键问题：不用线程，如何构建并发服务器
  * 基于事件的并发（event-based concurrency，如 node.js）、
  * 问题场景：
    * 多线程应用中，正确处理并发很有难度；
    * 开发者无法控制多线程在某一时刻的调度。
* 基本想法：事件循环（event loop）
  * 我们等待某事（即“事件”）发生；当它发生时，检查事件类型，然后做少量的相应工作（可能是I/O请求，或者调度其他事件准备后续处理）。
  * 事件处理程序（event handler，唯一活动）、对调度的显式控制
* 重要 API：select()（ 或 poll() ）
  * 检查是否有任何应该关注的进入I/O。
  * 阻塞（或同步，synchronous）接口、非阻塞（或异步，asynchronous）接口、非阻塞事件循环
  * `select()` 
    * 可以让你检查描述符是否可以读取和写入
    * 请注意超时参数（常见 NULL，0）
* 使用 select()
  * 传入消息、网络套接字
* 为何更简单？无须锁
  * 线程化程序、并发性错误、细粒度控制
  * 提示：请勿阻塞基于事件的服务器
* 一个问题：阻塞系统调用
  * 自然重叠（overlap）、常自然和直接。
* 解决方案：异步 I/O
  * 异步 I/O（asynchronous I/O）、struct aiocb 或 AIO 控制块（AIO control block）、异步读取（asynchronous read）、EINPROGRESS、轮询（poll）、基于中断（interrupt）、UNIX 信号（signal）、现代 UNIX 变体、信号处理程序（signal handler）、HUP（挂断）、INT（中断）、SEGV（段违规）、SIG 前缀、信号捕捉
* 另一个问题：状态管理
  * 手工栈管理（manual stack management）、基于事件编程
  * “延续（continuation）”：基本上，在某些数据结构中，记录完成处理该事件需要的信息。当事件发生时（即磁盘I/O完成时），查找所需信息并处理事件。
* 什么事情仍然很难
  * 当系统从单个CPU转向多个CPU时，基于事件的方法的一些简单性就消失了。
  * 在现代多核系统上，无锁的简单事件处理已不再可能，且不能很好地与某些类型的系统活动集成。
  * 虽然异步磁盘 I/O 现在可以在大多数平台上使用，但是花了很长时间才做到这一点，而且与异步网络 I/O 集成不会像你想象的那样有简单和统一的方式。
  * 显式阻塞、隐式阻塞、函数语义变化、集成难度、线程、事件、Tcl/Tk
* 疑问 / 感悟
  * 异步调用的单词 asynchronous，为什么看着比较奇怪？



2023/06/10 21:59:50

------



### 第34章 并发的总结对话

* 摘录
  * 可以看看最早的并发算法的论文，有很多都是有问题的，所以不理解这些代码也不必难过。
  * 为了写出写出正确的并发程序。首先，尽可能简单。避免复杂的线程交互，使用已被证实的线程交互方式。
  * 只在需要的时候才并发，尽可能不用它。过早地优化是最糟糕的。
  * 我们学习到的知识仅仅是冰山一角，还需要大量的阅读学习，以及大量的编码练习。课程上的时间是远远不够的。
  * 相互穿插、生产者—消费者队列、范式、并行的数据分析代码



2023/06/11 1:50:22

------









