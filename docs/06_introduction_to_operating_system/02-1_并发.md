### 02 并发

Date：2023/05/28 13:01:27

------



[TOC]



------



### 第25章 关于并发的对话

* 摘录
  * 例子：桃子，每个食客首先在视觉上识别桃子，然后试图抓住并吃掉桃子。这种方法有什么问题？
  * 让很多人同时抓起桃子，速度更快。但以我的方式，我们只是一次一个，这是正确的，但速度较慢。最好的方法是既快速又正确。
  * 永远不要忘记具体概念。
  * 多线程应用程序中，每个线程都像在这个程序中运行的独立代理程序，代表程序做事。但是这些线程访问内存，对于它们来说，每个内存节点就像一个桃子。如果我们不协调线程之间的内存访问，程序将无法按预期工作。懂了吗？
  * 操作系统本身是第一个并发程序——它必须非常小心地访问自己的内存，否则会发生许多奇怪而可怕的事情。
* 多线程（multi-threaded）应用程序、线程（thread）、锁（lock）、条件变量（condition variable）



------



### 第26章 并发：介绍

* 线程（thread）：

  * 定位：为单个运行进程提供的新抽象。
  * 复用、执行点、多线程（multi-threaded）、程序计数器；每个线程类似于**独立的**进程，**但它们共享地址空间**，从而能够访问相同的数据。
  * 结构对比：程序计数器（PC）、一组计算寄存器、线程（T1）、线程（T2）、上下文切换（context switch）、进程控制块（Process Control Block，PCB）、线程控制块（Thread Control Block，TCB）、线程本地（thread-local）存储
  * 主要区别：
    * 地址空间保持不变（即不需要切换当前使用的页表）。
    * 单线程（single-threaded）进程（一个栈），多线程（每个线程一个栈）

  ![img](images/02-1_并发/epub_30179184_118.jfif)

* 实例：线程创建

  * 类似函数调用，为被调用例程创建一个新的执行线程，可独立于调用者运行，返回顺序不定。

* 为什么更糟糕：共享数据

  * 确定的（deterministic）、反汇编程序（disassembler）
  * `prompt> objdump -d main` （产生程序中所有指令的长列表）

* 核心问题：不可控的调度

  * 时钟中断发生、寄存器虚拟化、例子（51 覆盖，少了一次递增）、可变长度指令、**竞态条件（race condition）**、不确定的（indeterminate）、临界区（critical section）、互斥（mutual exclusion）
  * 由于运气不好（即在执行过程中发生的上下文切换），我们得到了错误的结果。
  * 临界区是访问共享变量（或更一般地说，共享资源）的代码片段，**一定不能**由多个线程同时执行。

  ![img](images/02-1_并发/epub_30179184_122.jfif)

* 原子性愿望

  * 原子方式（atomically）执行（无中间态）、同步原语（synchronization primitive，有用指令+通用集合）、多线程代码、同步受控访问、互斥原语、条件变量（condition variable）
  * **临界区**：指访问共享资源的一段代码，资源通常是一个变量或数据结构。
  * **竞态条件**：出现在多个执行线程大致同时进入临界区时，它们都试图更新共享的数据结构，导致了令人惊讶的（也许是不希望的）结果。
  * **不确定性**：程序由一个或多个竞态条件组成，程序的输出因运行而异，具体取决于哪些线程在何时运行，从而导致结果是不确定的。
  * **不确定性**：
  * **互斥执行**：可以保证只有一个线程进入临界区，从而避免出现竞态，并产生确定的程序输出。
  * 关键问题：如何实现同步

* 还有一个问题：等待另一个线程

  * 线程的**交互**
    * 访问共享变量
    * 线程等待

* 小结：为什么操作系统课要研究并发

  * 操作系统是第一个并发程序、inode、不合时宜的中断、**原子操作**、事务（transaction）
  * 原子化（atomic）：“全部或没有”

* 疑问 / 感悟

  * “封装” 是否属于利用原子性特征？合适的抽象，隐蔽某些细节，看作一个整体。
  * 线程的交互，更像是线程之间存在的各种相互作用情况。



2023/05/28 20:31:17

------



### 第27章 插叙：线程API

* 关键问题：如何创建和控制线程？
* 线程创建
* 线程完成
* 锁
* 条件变量
* 编译和运行



------



### 第28章 锁

* 锁的基本思想
* Pthread 锁
* 实现一个锁
* 评价锁
* 控制中断
* 测试并设置指令（原子交换）
* 实现可用的自旋锁
* 评价自旋锁
* 比较并交换
* 链接的加载和条件式存储指令
* 获取并增加
* 自旋过多：怎么办
* 简单方法：让出来吧，宝贝
* 使用队列：休眠替代自旋
* 不同操作系统，不同实现
* 两阶段锁



------



### 第29章 基于锁的并发数据结构

* 关键问题：如何给数据结构加锁？
* 并发计数器
  * 简单但无法扩展
  * 可扩展的计数
* 并发链表
  * 扩展链表
* 并发队列
* 并发散列表



------



### 第30章 条件变量

* 关键问题：如何等待一个条件？
* 定义和程序
* 生产者/消费者（有界缓冲区）问题
  * 有问题的方案
  * 较好但仍有问题的方案：使用While语句替代If
  * 单值缓冲区的生产者/消费者方案
  * 最终的生产者/消费者方案
* 覆盖条件



------



### 第31章 信号量

* 关键问题：如何使用信号量？
* 信号量的定义
* 二值信号量（锁）
* 信号量用作条件变量
* 生产者/消费者（有界缓冲区）问题
  * 解决方案：增加互斥
  * 避免死锁
  * 最后，可行的方案
* 读者—写者锁
* 哲学家就餐问题
  * 有问题的解决方案
  * 一种方案：破除依赖
* 如何实现信号量



------



### 第32章 常见并发问题

* 关键问题：如何处理常见的并发缺陷
* 有哪些类型的缺陷
* 非死锁缺陷
  * 违反顺序缺陷
  * 非死锁缺陷：小结
* 死锁缺陷
  * 关键问题：如何对付死锁
  * 为什么发生死锁
  * 产生死锁的条件
  * 预防
    * 循环等待
    * 持有并等待
    * 非抢占
    * 互斥
    * 通过调度避免死锁
    * 检查和恢复





------



### 第33章 基于事件的并发（进阶）

* 关键问题：不用线程，如何构建并发服务器
* 基本想法：事件循环
* 重要 API：select()（ 或 poll() ）
* 使用 select()
* 为何更简单？无须锁
* 一个问题：阻塞系统调用
* 解决方案：异步I/O
* 另一个问题：状态管理
* 什么事情仍然很难



------



### 第34章 并发的总结对话

* 





------









