### C03

* 作业：
* 书中问题：



------



### C04

* 作业：
  * （模拟）模拟作业以模拟器的形式出现，你运行它以确保理解某些内容。模拟器通常是Python程序，它们让你能够生成不同的问题（使用不同的随机种子），也让程序为你解决问题（带-c标志），以便你检查答案。使用-h或--help标志运行任何模拟器，将提供有关模拟器所有选项的更多信息。每个模拟器附带的README文件提供了有关如何运行它的更多详细信息，其中详细描述了每个标志。
  * 程序process-run.py让你查看程序运行时进程状态如何改变，是在使用CPU（例如，执行相加指令）还是执行I/O（例如，向磁盘发送请求并等待它完成）。详情请参阅README文件。
* 书中问题：
  * 1．用以下标志运行程序：./process-run.py -l 5:100,5:100。CPU利用率（CPU使用时间的百分比）应该是多少？为什么你知道这一点？利用 -c标记查看你的答案是否正确。
  * 2．现在用这些标志运行：./process-run.py -l 4:100,1:0。这些标志指定了一个包含4条指令的进程（都要使用CPU），并且只是简单地发出I/O并等待它完成。完成这两个进程需要多长时间？利用-c检查你的答案是否正确。
  * 3．现在交换进程的顺序：./process-run.py -l 1:0,4:100。现在发生了什么？交换顺序是否重要？为什么？同样，用-c看看你的答案是否正确。
  * 4．现在探索另一些标志。一个重要的标志是-S，它决定了当进程发出I/O时系统如何反应。将标志设置为SWITCH_ON_END，在进程进行I/O操作时，系统将不会切换到另一个进程，而是等待进程完成。当你运行以下两个进程时，会发生什么情况？一个执行I/O，另一个执行CPU工作。（-l 1:0,4:100 -c -S SWITCH_ON_END）
  * 5．现在，运行相同的进程，但切换行为设置，在等待I/O时切换到另一个进程（-l 1:0,4:100 -c -S SWITCH_ON_IO）。现在会发生什么？利用-c来确认你的答案是否正确。
  * 6．另一个重要的行为是I/O完成时要做什么。利用-I IO_RUN_LATER，当I/O完成时，发出它的进程不一定马上运行。相反，当时运行的进程一直运行。当你运行这个进程组合时会发生什么？（./process-run.py -l 3:0,5:100,5:100,5:100 -S SWITCH_ON_IO -I IO_RUN_LATER -c -p）系统资源是否被有效利用？
  * 7．现在运行相同的进程，但使用-I IO_RUN_IMMEDIATE设置，该设置立即运行发出I/O的进程。这种行为有何不同？为什么运行一个刚刚完成I/O的进程会是一个好主意？
  * 8．现在运行一些随机生成的进程，例如-s 1 -l 3:50,3:50, -s 2 -l 3:50,3:50, -s 3 -l 3:50,3:50。看看你是否能预测追踪记录会如何变化？当你使用-I IO_RUN_IMMEDIATE与-I IO_RUN_LATER时会发生什么？当你使用-S SWITCH_ON_IO与-S SWITCH_ON_END时会发生什么？



------



### C05

* 作业：（编码）在这个作业中，你要熟悉一下刚读过的进程管理API。别担心，它比听起来更有趣！如果你找到尽可能多的时间来编写代码，通常会增加成功的概率[5]，为什么不现在就开始呢？
* 书中问题：
  * 1．编写一个调用fork()的程序。在调用fork()之前，让主进程访问一个变量（例如x）并将其值设置为某个值（例如100）。子进程中的变量有什么值？当子进程和父进程都改变x的值时，变量会发生什么？
  * 2．编写一个打开文件的程序（使用open()系统调用），然后调用fork()创建一个新进程。子进程和父进程都可以访问open()返回的文件描述符吗？当它们并发（即同时）写入文件时，会发生什么？
  * 3．使用fork()编写另一个程序。子进程应打印“hello”，父进程应打印“goodbye”。你应该尝试确保子进程始终先打印。你能否不在父进程调用wait()而做到这一点呢？
  * 4．编写一个调用fork()的程序，然后调用某种形式的exec()来运行程序/bin/ls。看看是否可以尝试exec()的所有变体，包括execl()、execle()、execlp()、execv()、execvp()和execvP()。为什么同样的基本调用会有这么多变种？
  * 5．现在编写一个程序，在父进程中使用wait()，等待子进程完成。wait()返回什么？如果你在子进程中使用wait()会发生什么？
  * 6．对前一个程序稍作修改，这次使用waitpid()而不是wait()。什么时候waitpid()会有用？
  * 7．编写一个创建子进程的程序，然后在子进程中关闭标准输出（STDOUT_FILENO）。如果子进程在关闭描述符后调用printf()打印输出，会发生什么？
  * 8．编写一个程序，创建两个子进程，并使用pipe()系统调用，将一个子进程的标准输出连接到另一个子进程的标准输入。



------



### C06

* 作业：（测量）测量作业是小型练习。你可以编写代码在真实机器上运行，从而测量操作系统或硬件性能的某些方面。这样的作业背后的想法是给你一点实际操作系统的实践经验。



------



### C07

* 作业：scheduler.py这个程序允许你查看不同调度程序在调度指标（如响应时间、周转时间和总等待时间）下的执行情况。详情请参阅README文件。

* 书中问题：
  * 1．使用SJF和FIFO调度程序运行长度为200的3个作业时，计算响应时间和周转时间。
  * 2．现在做同样的事情，但有不同长度的作业，即100、200和300。
  * 3．现在做同样的事情，但采用RR调度程序，时间片为1。
  * 4．对于什么类型的工作负载，SJF提供与FIFO相同的周转时间？
  * 5．对于什么类型的工作负载和量子长度，SJF与RR提供相同的响应时间？
  * 6．随着工作长度的增加，SJF的响应时间会怎样？你能使用模拟程序来展示趋势吗？
  * 7．随着量子长度的增加，RR的响应时间会怎样？你能写出一个方程，计算给定N个工作时，最坏情况的响应时间吗？

------



### C08

* 作业：程序mlfq.py允许你查看本章介绍的MLFQ调度程序的行为。详情请参阅README文件。
* 书中问题：
  * 1．只用两个工作和两个队列运行几个随机生成的问题。针对每个工作计算MLFQ的执行记录。限制每项作业的长度并关闭I/O，让你的生活更轻松。
  * 2．如何运行调度程序来重现本章中的每个实例？
  * 3．将如何配置调度程序参数，像轮转调度程序那样工作？
  * 4．设计两个工作的负载和调度程序参数，以便一个工作利用较早的规则4a和4b（用-S标志打开）来“愚弄”调度程序，在特定的时间间隔内获得99%的CPU。
  * 5．给定一个系统，其最高队列中的时间片长度为10ms，你需要如何频繁地将工作推回到最高优先级级别（带有-B标志），以保证一个长时间运行（并可能饥饿）的工作得到至少5%的CPU？
  * 6．调度中有一个问题，即刚完成I/O的作业添加在队列的哪一端。-I标志改变了这个调度模拟器的这方面行为。尝试一些工作负载，看看你是否能看到这个标志的效果。



------



### C09

* 作业：lottery.py这个程序允许你查看彩票调度程序的工作原理。详情请参阅README文件。
* 书中问题：
  
  * 1．计算3个工作在随机种子为1、2和3时的模拟解。
  
  * 2．现在运行两个具体的工作：每个长度为10，但是一个（工作0）只有一张彩票，另一个（工作1）有100张（−l 10∶1,10∶100）。
  
    彩票数量如此不平衡时会发生什么？在工作1完成之前，工作0是否会运行？多久？一般来说，这种彩票不平衡对彩票调度的行为有什么影响？
  
  * 3．如果运行两个长度为100的工作，都有100张彩票（−l100∶100,100∶100），调度程序有多不公平？运行一些不同的随机种子来确定（概率上的）答案。不公平性取决于一项工作比另一项工作早完成多少。
  
  * 4．随着量子规模（-q）变大，你对上一个问题的答案如何改变？
  
  * 5．你可以制作类似本章中的图表吗
  
    还有什么值得探讨的？用步长调度程序，图表看起来如何？



------



### C10

* 作业：
* 书中问题：
  * 



------



### C11

* 作业：
* 书中问题：
  * 



------



### C12

* 作业：
* 书中问题：
  * 



------



### C13

* 作业：
* 书中问题：
  * 



------



### C14

* 作业：
  * （编码）在这个作业中，你会对内存分配有所了解。首先，你会写一些错误的程序（好玩！）。然后，利用一些工具来帮助你找到其中的错误。最后，你会意识到这些工具有多棒，并在将来使用它们，从而使你更加快乐和高效。
  * 你要使用的第一个工具是调试器gdb。关于这个调试器有很多需要了解的知识，在这里，我们只是浅尝辄止。
  * 你要使用的第二个工具是valgrind [SN05]。该工具可以帮助查找程序中的内存泄露和其他隐藏的内存问题。如果你的系统上没有安装，请访问valgrind网站并安装它。
* 书中问题：
  * 1．编写一个名为null.c的简单程序，它创建一个指向整数的指针，将其设置为NULL，然后尝试对其进行释放内存操作。把它编译成一个名为null的可执行文件。当你运行这个程序时会发生什么？
  * 2．编译该程序，其中包含符号信息（使用-g 标志）。这样做可以将更多信息放入可执行文件中，使调试器可以访问有关变量名称等的更多有用信息。通过输入gdb null，在调试器下运行该程序，然后，一旦gdb运行，输入run。gdb显示什么信息？
  * 3．对这个程序使用valgrind工具。我们将使用属于valgrind的memcheck工具来分析发生的情况。输入以下命令来运行程序：valgrind --leak-check=yes null。当你运行它时会发生什么？你能解释工具的输出吗？
  * 4．编写一个使用malloc()来分配内存的简单程序，但在退出之前忘记释放它。这个程序运行时会发生什么？你可以用gdb来查找它的任何问题吗？用valgrind呢（再次使用--leak-check=yes标志）？
  * 5．编写一个程序，使用malloc()创建一个名为data、大小为100的整数数组。然后，将data[100]设置为0。当你运行这个程序时会发生什么？当你使用valgrind运行这个程序时会发生什么？程序是否正确？
  * 6．创建一个分配整数数组的程序（如上所述），释放它们，然后尝试打印数组中某个元素的值。程序会运行吗？当你使用valgrind时会发生什么？
  * 7．现在传递一个有趣的值来释放（例如，在上面分配的数组中间的一个指针）。 会发生什么？你是否需要工具来找到这种类型的问题？
  * 8．尝试一些其他接口来分配内存。例如，创建一个简单的向量似的数据结构，以及使用realloc()来管理向量的相关函数。使用数组来存储向量元素。当用户在向量中添加条目时，请使用realloc()为其分配更多空间。这样的向量表现如何？它与链表相比如何？使用valgrind来帮助你发现错误。
  * 9．花更多时间阅读有关使用gdb和valgrind的信息。了解你的工具至关重要，花时间学习如何成为UNIX和C环境中的调试器专家。



------



### C15

* 作业：
* 书中问题：
  * 



------



### C16

* 作业：
* 书中问题：
  * 



------



### C17

* 作业：
* 书中问题：
  * 



------



### C18

* 作业：
* 书中问题：
  * 



------



### C19

* 作业：
* 书中问题：
  * 



------



### C20

* 作业：
* 书中问题：
  * 



------



### C21

* 作业：
* 书中问题：
  * 



------



### C22

* 作业：
* 书中问题：
  * 



------



### C23

* 作业：
* 书中问题：
  * 



------



### C24

* 作业：
* 书中问题：
  * 



------



